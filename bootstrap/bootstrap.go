package bootstrap

import (
	"encoding/json"
	"fmt"
	"go/doc"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"text/template"

	"github.com/Apakhov/ayprotogen/bootstrap/parse"

	"github.com/pkg/errors"
)

var methodDocRegex = regexp.MustCompile(`(?s).*ayproto:method(\{.*\})\n`)

type methodDoc struct {
	Name     string
	SVC      int32    `json:"svc"`
	Wrappers []string `json:"wrappers"`
}

func getMethodDoc(s string, name string) (*methodDoc, error) {
	matches := methodDocRegex.FindStringSubmatch(s)
	if len(matches) != 2 {
		return nil, nil
	}
	doc := new(methodDoc)
	err := json.Unmarshal([]byte(matches[1]), doc)
	if err != nil {
		return nil, errors.Wrap(err, "bad ayproto:method docs")
	}
	doc.Name = name
	return doc, nil
}

var packetDocRegex = regexp.MustCompile(`(?s).*ayproto:packet(\{.*\}|)\n`)

type packetDoc struct {
	Name string
}

func getPacketDoc(s string, name string) (*packetDoc, error) {
	matches := packetDocRegex.FindStringSubmatch(s)
	if len(matches) != 2 {
		return nil, nil
	}
	if len(matches[1]) == 0 {
		matches[1] = "{}"
	}
	doc := new(packetDoc)
	err := json.Unmarshal([]byte(matches[1]), doc)
	if err != nil {
		return nil, errors.Wrap(err, "bad ayproto:packet docs")
	}
	doc.Name = name
	return doc, nil
}

func ParseDir(dir string) (string, string, []packetDoc, map[string]map[int32]methodDoc, error) {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(o os.FileInfo) bool {
		return strings.HasSuffix(o.Name(), ".go") && !strings.HasSuffix(o.Name(), "_ayproto.go")
	}, parser.ParseComments)

	if err != nil {
		return "", "", nil, nil, err
	}

	packets := make([]packetDoc, 0)
	servers := make(map[string]map[int32]methodDoc, 0)
	p := parse.Parser{}
	err = p.Parse(dir)
	if err != nil {
		return "", "", nil, nil, err
	}
	impPath := ""
	for name, pkg := range pkgs {
		impPath = name
		fmt.Println("!!!!!", name)
		docs := doc.New(pkg, name, 0)
		for _, t := range docs.Types {
			doc, err := getPacketDoc(t.Doc, t.Name)
			if err != nil {
				return "", "", nil, nil, err
			}
			if doc != nil {
				packets = append(packets, *doc)
				continue
			}
			for _, m := range t.Methods {
				doc, err := getMethodDoc(m.Doc, m.Name)
				if err != nil {
					return "", "", nil, nil, err
				}
				if doc != nil {
					if servers[t.Name] == nil {
						servers[t.Name] = make(map[int32]methodDoc)
					}
					if _, ok := servers[t.Name][doc.SVC]; ok {
						return "", "", nil, nil, errors.Errorf(
							"two methods with svc %d: %s, %s\n",
							doc.SVC, doc.Name, servers[t.Name][doc.SVC].Name,
						)
					}
					servers[t.Name][doc.SVC] = *doc
				}
			}
		}

	}
	return p.ImportPath, impPath, packets, servers, nil
}

type btTmInfo struct {
	Dir     string
	Trg     string
	PkgName string
	Packets []packetDoc
	Servers map[string]map[int32]methodDoc
}

var btTm = `//+build ignore

// Code generated by ayprotogen: bootstrap file for generating ayproto handler methods. DO NOT EDIT.

package main

import (
	"github.com/Apakhov/ayproto/packgen"
	pkg "{{.PkgName}}"
	"reflect"

	"log"
)

func main() {
	g := packgen.NewGenerator("{{.Trg}}", "{{.PkgName}}")
{{ range .Packets }}
	g.AddStruct(reflect.TypeOf(pkg.{{ .Name }}{})) 
{{ end }}
{{ range $serv, $handlers := .Servers }}
	g.AddServer(reflect.TypeOf(pkg.{{ $serv }}{}),
	{{ range $handler, $doc := $handlers }}
		reflect.TypeOf((&pkg.{{ $serv }}{}).{{ $doc.Name }}), packgen.MethodDoc{
			Name: "{{ $doc.Name }}",
			SVC: {{ $doc.SVC }},
			Wrappers: []string{ {{ range $doc.Wrappers }} {{ . }}, {{ end }} },
		}, 
	{{ end }}
	) 
{{ end }}
	if len(g.Errors()) != 0 {
		for _, err := range g.Errors() {
			log.Println(err.Name)
			log.Println(err.Err.Error())
		}
		return
	}
	g.Gen()

	err := g.WriteFiles("{{.Dir}}")
	if err != nil {
		log.Println(err)
	}
}
`

func GenBootstrap(dir, trg, pkgname string, packets []packetDoc, servers map[string]map[int32]methodDoc) error {
	f, err := os.Create(dir + "/bootstrap_ayproto.go")
	if err != nil {
		return err
	}
	defer f.Close()

	tm, err := template.New("bt").Parse(btTm)
	if err != nil {
		return err
	}

	bld := strings.Builder{}

	err = tm.Execute(&bld, btTmInfo{
		Dir:     dir,
		Trg:     trg,
		PkgName: pkgname,
		Packets: packets,
		Servers: servers,
	})
	if err != nil {
		return err
	}

	_, err = f.WriteString(bld.String())
	return err
}

func RunBootstrap(dir string) error {
	btsFileName := dir + "/bootstrap_ayproto.go"
	out, err := exec.Command("go", "run", btsFileName).CombinedOutput()
	if err != nil {
		log.Println(string(out))
		log.Println("failed to generate:", err)
	}
	return err
}

func CleadUp(dir string, succ bool) error {
	btsFileName := dir + "/bootstrap_ayproto.go"
	os.Remove(btsFileName)
	if succ {
		realF, err := os.Create(dir + "/packgen_ayproto.go")
		if err != nil {
			return err
		}
		defer realF.Close()
		tmpF, err := os.Open(dir + "/packgen_ayproto.go.temp")
		if err != nil {
			return err
		}
		defer tmpF.Close()
		t, err := ioutil.ReadAll(tmpF)
		if err != nil {
			return err
		}
		realF.Write(t)
	}
	os.Remove(dir + "/packgen_ayproto.go.temp")
	return errors.Wrap(exec.Command("go", "fmt", dir+"/packgen_ayproto.go").Run(), "cant format generated file")
}
