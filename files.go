package main

import "github.com/Apakhov/ayprotogen/bootstrap"

var gfiles = []bootstrap.GFile{bootstrap.GFile{Name:"packgen/errors.go", Content:"package packgen\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar (\n\tErrNotStruct     = errors.New(\"not struct\")\n\tErrBadType       = errors.New(\"bad type\")\n\tErrNoStructName  = errors.New(\"no name\")\n\tErrPtrNotAllowed = errors.New(\"poiters ot allowed\")\n\n\tErrNotFunc      = errors.New(\"not func\")\n\tErrFuncSiganure = errors.New(\"function not of type func (context.Context, in) (out, err)\")\n)\n\ntype StructErr struct {\n\tErr  error\n\tName string\n}\n\nfunc errorWrap(err error, msg string) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%s: %s\", msg, err.Error())\n}\n"}, bootstrap.GFile{Name:"packgen/generator.go", Content:"package packgen\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype strBuilder struct {\n\tstrings.Builder\n}\n\nfunc (b *strBuilder) WriteStringf(format string, a ...interface{}) {\n\tb.WriteString(fmt.Sprintf(format, a...))\n}\nfunc (b *strBuilder) WriteStringfn(format string, a ...interface{}) {\n\tb.WriteString(fmt.Sprintf(format, a...))\n\tb.WriteByte('\\n')\n}\n\ntype strVersionaizer struct {\n\tmp map[string]int\n}\n\nfunc newStrVersionaizer() strVersionaizer {\n\treturn strVersionaizer{\n\t\tmp: make(map[string]int),\n\t}\n}\nfunc (v *strVersionaizer) version(str string) string {\n\tif _, ok := v.mp[str]; !ok {\n\t\tv.mp[str] = 0\n\t}\n\tv.mp[str] = v.mp[str] + 1\n\treturn fmt.Sprintf(\"%s%d\", str, v.mp[str])\n}\n\ntype Generator struct {\n\t*strBuilder\n\tstrVersionaizer\n\ttargetpkg  string\n\ttargetpath string\n\tpkgs       map[string]string\n\tstructs    map[string]*rootNode\n\tservers    []*server\n\terrors     []StructErr\n}\n\nfunc NewGenerator(targetpkg string, targetpath string) *Generator {\n\treturn &Generator{\n\t\tstrBuilder:      &strBuilder{},\n\t\tstrVersionaizer: newStrVersionaizer(),\n\t\ttargetpkg:       targetpkg,\n\t\ttargetpath:      targetpath,\n\t\tpkgs:            make(map[string]string),\n\t\tstructs:         make(map[string]*rootNode),\n\t\terrors:          make([]StructErr, 0),\n\t}\n}\n\nfunc (g *Generator) addErr(err StructErr) {\n\tg.errors = append(g.errors, err)\n}\n\nfunc (g *Generator) Errors() []StructErr {\n\treturn g.errors\n}\n\nfunc (g *Generator) addPkg(path string) {\n\tif path == g.targetpath {\n\t\treturn\n\t}\n\tif _, ok := g.pkgs[path]; !ok {\n\t\tg.pkgs[path] = \"pkg\" + strconv.Itoa(len(g.pkgs))\n\t}\n\treturn\n}\n\nfunc (g *Generator) getPrefix(path string) string {\n\tif path == g.targetpath {\n\t\treturn \"\"\n\t}\n\treturn g.pkgs[path] + \".\"\n}\n\nfunc (g *Generator) Gen() {\n\tg.genHeader()\n\tfor _, v := range g.structs {\n\t\tv.genMarsh(\"\")\n\t\tv.genUnmarsh(\"\")\n\t}\n\tfor _, v := range g.servers {\n\t\tv.gen()\n\t}\n}\n\nfunc (g *Generator) genHeader() {\n\tg.WriteStringfn(\"// Code generated by ayprotogen: DO NOT EDIT.\")\n\tg.WriteStringfn(\"package %s\", g.targetpkg)\n\tg.WriteStringfn(\"import (\")\n\tg.WriteStringfn(`\"bytes\"`)\n\tg.WriteStringfn(`\"context\"`)\n\tg.WriteStringfn(`\"fmt\"`)\n\tfor path, name := range g.pkgs {\n\t\tg.WriteStringfn(`%s \"%s\"`, name, path)\n\t}\n\tg.WriteStringfn(`\"github.com/Apakhov/ayproto\"`)\n\tg.WriteStringfn(\")\")\n}\n\nfunc (g *Generator) WriteFiles(dir string) error {\n\ttmpF, err := os.Create(dir + \"/packgen_ayproto.go.temp\")\n\tif err != nil {\n\t\treturn errorWrap(err, \"cant open temp file\")\n\t}\n\tdefer tmpF.Close()\n\n\t_, err = fmt.Fprintln(tmpF, g.String())\n\tif err != nil {\n\t\treturn errorWrap(err, \"cant write to temp file\")\n\t}\n\n\treturn nil\n}\n"}, bootstrap.GFile{Name:"packgen/gennode.go", Content:"package packgen\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"reflect\"\n)\n\ntype genNode interface {\n\tbase() *nodeBase\n\tgetType() string\n\tgenMarsh(acc string)\n\tgenUnmarsh(acc string)\n}\n\ntype nodeBase struct {\n\tg      *Generator\n\tparent genNode\n\tchilds []genNode\n}\n\nfunc (nb *nodeBase) base() *nodeBase {\n\treturn nb\n}\n\ntype opts struct {\n\tmode int\n}\n\nfunc (o opts) updateMode(f reflect.StructField) opts {\n\ttag := f.Tag.Get(\"mode\")\n\tif tag == \"ber\" {\n\t\to.mode = 1\n\t}\n\tif tag == \"d\" || tag == \"default\" {\n\t\to.mode = 0\n\t}\n\treturn o\n}\n\nfunc (o opts) defaultMode() opts {\n\to.mode = 0\n\treturn o\n}\n\nfunc makeChildNode(node genNode, t reflect.Type, o opts) error {\n\tnewBase := newNodeBase(node.base().g)\n\tvar newNode genNode\n\tswitch t.Kind() {\n\tcase reflect.Struct:\n\t\to = o.defaultMode()\n\t\tnewNode = newStructNode(newBase, t)\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\terr := makeChildNode(newNode, t.Field(i).Type, o.updateMode(t.Field(i)))\n\t\t\tif err != nil {\n\t\t\t\treturn errorWrap(err, fmt.Sprint(\"generating \", t))\n\t\t\t}\n\t\t}\n\tcase reflect.Slice:\n\t\tnewNode = newSliceNode(newBase, o)\n\t\terr := makeChildNode(newNode, t.Elem(), o.defaultMode())\n\t\tif err != nil {\n\t\t\treturn errorWrap(err, fmt.Sprint(\"generating \", t))\n\t\t}\n\tdefault:\n\t\tvar err error\n\t\tnewNode, err = newSimpleNode(newBase, t, o)\n\t\tif err != nil {\n\t\t\treturn errorWrap(err, fmt.Sprint(\"generating \", t))\n\t\t}\n\t}\n\tnode.base().childs = append(node.base().childs, newNode)\n\tnewNode.base().parent = node\n\treturn nil\n}\n\nfunc newNodeBase(g *Generator) *nodeBase {\n\treturn &nodeBase{\n\t\tg:      g,\n\t\tchilds: make([]genNode, 0),\n\t}\n}\n\ntype rootNode struct{ *nodeBase }\n\nfunc (n *rootNode) getType() string {\n\treturn \"\"\n}\n\nfunc (n *rootNode) genMarsh(acc string) {\n\tg := n.g\n\tg.WriteStringfn(\"func (v *%s) MarshalAyproto() ([]byte, error) {\", n.childs[0].getType())\n\tg.WriteStringfn(\"res := make([]byte, 0)\")\n\tn.childs[0].genMarsh(\"v\")\n\tg.WriteStringfn(\"return res, nil\")\n\tg.WriteStringfn(\"}\")\n\treturn\n}\n\nfunc (n *rootNode) genUnmarsh(acc string) {\n\tg := n.g\n\tg.WriteStringfn(\"func (v *%s) UnmarshalAyproto(r *bytes.Reader) error {\", n.childs[0].getType())\n\tg.WriteStringfn(\"var err error\")\n\tg.WriteStringfn(\"var l uint32\") // slice len\n\tg.WriteStringfn(\"_,_ = l,err\")\n\tg.WriteStringfn(\"var int8conv uint8\")\n\tg.WriteStringfn(\"var int16conv uint16\")\n\tg.WriteStringfn(\"var int32conv uint32\")\n\tg.WriteStringfn(\"var int64conv uint64\")\n\tg.WriteStringfn(\"var intconv uint32\")\n\tg.WriteStringfn(\"var uintconv uint32\")\n\tg.WriteStringfn(\"_,_,_,_,_,_ = int8conv, int16conv, int32conv, int64conv, intconv, uintconv\")\n\tn.childs[0].genUnmarsh(\"v\")\n\tg.WriteStringfn(\"return nil\")\n\tg.WriteStringfn(\"}\")\n\treturn\n}\n\ntype structNode struct {\n\t*nodeBase\n\tname string\n\tt    reflect.Type\n}\n\nfunc newStructNode(base *nodeBase, t reflect.Type) *structNode {\n\tbase.g.addPkg(t.PkgPath())\n\treturn &structNode{\n\t\tnodeBase: base,\n\t\tt:        t,\n\t}\n}\n\nfunc (n *structNode) getType() string {\n\tname := n.t.Name()\n\tif name == \"\" { // anon struct\n\t\tlog.Println(\"cant use anonimus struct\")\n\t\tpanic(\"anon struct\")\n\t}\n\treturn n.g.getPrefix(n.t.PkgPath()) + name\n}\n\nfunc (n *structNode) genMarsh(acc string) {\n\tfor i, child := range n.childs {\n\t\tchild.genMarsh(acc + \".\" + n.t.Field(i).Name)\n\t}\n\treturn\n}\n\nfunc (n *structNode) genUnmarsh(acc string) {\n\tfor i, child := range n.childs {\n\t\tchild.genUnmarsh(acc + \".\" + n.t.Field(i).Name)\n\t}\n\treturn\n}\n\ntype sliceNode struct {\n\t*nodeBase\n\tname string\n\topts\n}\n\nfunc newSliceNode(base *nodeBase, o opts) *sliceNode {\n\treturn &sliceNode{\n\t\tnodeBase: base,\n\t\topts:     o,\n\t}\n}\n\nfunc (n *sliceNode) getType() string {\n\treturn \"[]\" + n.childs[0].getType()\n}\n\nfunc (n *sliceNode) genMarsh(acc string) {\n\tn.g.WriteStringfn(\"res = ayproto.PackUint32(res, uint32(len(%s)), %d)\", acc, n.opts.mode)\n\tn.g.WriteStringfn(\"for _, v := range %s {\", acc)\n\tn.childs[0].genMarsh(\"v\")\n\tn.g.WriteStringfn(\"}\")\n\treturn\n}\n\nfunc (n *sliceNode) genUnmarsh(acc string) {\n\tn.g.WriteStringfn(mpFieldToUnpackSchema[reflect.Uint32], \"l\", n.opts.mode)\n\tn.g.WriteStringfn(\"if int64(l) > r.Size() {\")\n\tn.g.WriteStringfn(`return fmt.Errorf(\"cant unpack array - invalid array length %%d in packet of length %%d\", l, r.Size())`)\n\tn.g.WriteStringfn(\"}\")\n\tn.g.WriteStringfn(\"%s = make([]%s, l)\", acc, n.childs[0].getType())\n\tiv := n.g.version(\"i\")\n\tn.g.WriteStringfn(\"for %s := range %s {\", iv, acc)\n\tn.childs[0].genUnmarsh(fmt.Sprintf(\"%s[%s]\", acc, iv))\n\tn.g.WriteStringfn(\"}\")\n\treturn\n}\n\ntype simpleNode struct {\n\t*nodeBase\n\tname         string\n\tt            string\n\tpackSchema   string\n\tunpackSchema string\n\topts         opts\n}\n\nfunc newSimpleNode(base *nodeBase, t reflect.Type, o opts) (*simpleNode, error) {\n\tnt, err := nameFromReflect(t.Kind())\n\treturn &simpleNode{\n\t\tnodeBase:     base,\n\t\tt:            nt,\n\t\tpackSchema:   mpFieldToPackSchema[t.Kind()],\n\t\tunpackSchema: mpFieldToUnpackSchema[t.Kind()],\n\t\topts:         o,\n\t}, errorWrap(err, \"generating field\")\n}\n\nfunc (n *simpleNode) getType() string {\n\treturn n.t\n}\n\nfunc (n *simpleNode) genMarsh(acc string) {\n\tn.g.WriteStringfn(n.packSchema, acc, n.opts.mode)\n\treturn\n}\n\nfunc (n *simpleNode) genUnmarsh(acc string) {\n\tn.g.WriteStringfn(n.unpackSchema, acc, n.opts.mode)\n\treturn\n}\n\nvar mpFieldToPackSchema = map[reflect.Kind]string{\n\treflect.Int8:   \"res = ayproto.PackUint8( res, uint8(%s),  %d)\",\n\treflect.Int16:  \"res = ayproto.PackUint16(res, uint16(%s), %d)\",\n\treflect.Int32:  \"res = ayproto.PackUint32(res, uint32(%s), %d)\",\n\treflect.Int64:  \"res = ayproto.PackUint64(res, uint64(%s), %d)\",\n\treflect.Int:    \"res = ayproto.PackUint32(res, uint32(%s), %d)\",\n\treflect.Uint8:  \"res = ayproto.PackUint8( res, %s,         %d)\",\n\treflect.Uint16: \"res = ayproto.PackUint16(res, %s,         %d)\",\n\treflect.Uint32: \"res = ayproto.PackUint32(res, %s,         %d)\",\n\treflect.Uint64: \"res = ayproto.PackUint64(res, %s,         %d)\",\n\treflect.Uint:   \"res = ayproto.PackUint32(res, uint32(%s), %d)\",\n\treflect.String: \"res = ayproto.PackString(res, %s,         %d)\",\n}\n\nfunc simpleUnpack(f string) string {\n\treturn fmt.Sprintf(\"\"+\n\t\t\"err = %s(r, &(%%[1]s), %%[2]d)\\n\"+\n\t\t\"if err != nil {return fmt.Errorf(\\\"cant unpack %%[1]s: %%%%w\\\", err)}\", f)\n}\n\nfunc typedUnpack(f, convT, convF string) string {\n\treturn fmt.Sprintf(\"\"+\n\t\t\"err = %[2]s(r, &%[3]sconv, %%[2]d)\\n\"+\n\t\t\"if err != nil {return fmt.Errorf(\\\"cant unpack %%[1]s: %%%%w\\\", err)}\\n\"+\n\t\t\"%%[1]s = %[3]s(%[3]sconv)\", convF, f, convT)\n}\n\nvar mpFieldToUnpackSchema = map[reflect.Kind]string{\n\treflect.Int8:   typedUnpack(\"ayproto.UnpackUint8\", \"int8\", \"uint8\"),\n\treflect.Int16:  typedUnpack(\"ayproto.UnpackUint16\", \"int16\", \"uint16\"),\n\treflect.Int32:  typedUnpack(\"ayproto.UnpackUint32\", \"int32\", \"uint32\"),\n\treflect.Int64:  typedUnpack(\"ayproto.UnpackUint64\", \"int64\", \"uint64\"),\n\treflect.Int:    typedUnpack(\"ayproto.UnpackUint32\", \"int\", \"uint32\"),\n\treflect.Uint8:  simpleUnpack(\"ayproto.UnpackUint8\"),\n\treflect.Uint16: simpleUnpack(\"ayproto.UnpackUint16\"),\n\treflect.Uint32: simpleUnpack(\"ayproto.UnpackUint32\"),\n\treflect.Uint64: simpleUnpack(\"ayproto.UnpackUint64\"),\n\treflect.Uint:   typedUnpack(\"ayproto.UnpackUint32\", \"uint\", \"uint32\"),\n\treflect.String: simpleUnpack(\"ayproto.UnpackString\"),\n}\n"}, bootstrap.GFile{Name:"packgen/packgen.go", Content:"package packgen\n\nimport (\n\t\"context\"\n\t\"reflect\"\n)\n\nfunc (g *Generator) AddStruct(t reflect.Type) {\n\tif t.Kind() != reflect.Struct {\n\t\tg.addErr(StructErr{\n\t\t\tErr:  ErrNotStruct,\n\t\t\tName: t.Name(),\n\t\t})\n\t\treturn\n\t}\n\n\troot := &rootNode{newNodeBase(g)}\n\n\terr := makeChildNode(root, t, opts{})\n\tif err != nil {\n\t\tg.addErr(StructErr{\n\t\t\tErr:  err,\n\t\t\tName: t.Name(),\n\t\t})\n\t\treturn\n\t}\n\tg.structs[root.childs[0].getType()] = root\n}\n\nfunc (g *Generator) AddServer(t reflect.Type, ftDescr ...interface{}) {\n\tfor i := 0; i < len(ftDescr); i += 2 {\n\t\tft := ftDescr[i].(reflect.Type)\n\t\tg.AddMethod(ft)\n\t}\n\n\tif t.Kind() != reflect.Struct {\n\t\tg.addErr(StructErr{\n\t\t\tErr:  ErrNotStruct,\n\t\t\tName: t.Name(),\n\t\t})\n\t\treturn\n\t}\n\n\tg.servers = append(g.servers, newServer(newNodeBase(g), t, ftDescr...))\n}\n\nfunc checkMethodSiganure(t reflect.Type) bool {\n\tif t.NumIn() != 2 || // context, in msg\n\t\t!t.In(0).Implements(reflect.TypeOf((*context.Context)(nil)).Elem()) ||\n\t\tt.In(1).Kind() != reflect.Struct ||\n\t\tt.NumOut() < 1 { // out msgs\n\t\treturn false\n\t}\n\n\tfor i := 0; i < t.NumOut(); i++ {\n\t\tif t.Out(i).Kind() != reflect.Ptr || t.Out(i).Elem().Kind() != reflect.Struct {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (g *Generator) AddMethod(t reflect.Type) {\n\tif t.Kind() != reflect.Func {\n\t\tg.addErr(StructErr{\n\t\t\tErr:  ErrNotFunc,\n\t\t\tName: t.Name(),\n\t\t})\n\t\treturn\n\t}\n\n\tif !checkMethodSiganure(t) {\n\t\tg.addErr(StructErr{\n\t\t\tErr:  ErrFuncSiganure,\n\t\t\tName: t.Name(),\n\t\t})\n\t\treturn\n\t}\n\n\tg.AddStruct(t.In(1))\n\tfor i := 0; i < t.NumOut(); i++ {\n\t\tg.AddStruct(t.Out(i).Elem())\n\t}\n}\n"}, bootstrap.GFile{Name:"packgen/server.go", Content:"package packgen\n\nimport (\n\t\"reflect\"\n)\n\ntype MethodDoc struct {\n\tName     string\n\tSVC      int32\n\tWrappers []string\n}\n\ntype server struct {\n\tg      *Generator\n\ts      *structNode\n\tms     []reflect.Type\n\tdescrs []MethodDoc\n}\n\nfunc newServer(base *nodeBase, t reflect.Type, ftDescr ...interface{}) *server {\n\tserv := &server{\n\t\tg: base.g,\n\t\ts: newStructNode(base, t),\n\t}\n\n\tfor i := 0; i < len(ftDescr); i += 2 {\n\t\tft, descr := ftDescr[i].(reflect.Type), ftDescr[i+1].(MethodDoc)\n\t\tserv.ms = append(serv.ms, ft)\n\t\tserv.descrs = append(serv.descrs, descr)\n\t}\n\n\treturn serv\n}\n\nfunc (s *server) genHandle(t reflect.Type, doc MethodDoc) {\n\ts.g.WriteStringfn(\"case %d:\", doc.SVC)\n\ts.g.WriteStringfn(\"r := &%s{}\", t.In(1).Name())\n\ts.g.WriteStringfn(\"err := r.UnmarshalAyproto(bytes.NewReader(p.Data))\")\n\ts.g.WriteStringfn(\"fmt.Println(err)\")\n\ts.g.WriteStringfn(\"if err != nil {\")\n\ts.g.WriteStringfn(\"resBt = ayproto.GenericErrorResp\")\n\ts.g.WriteStringfn(\"break\")\n\ts.g.WriteStringfn(\"}\")\n\tresN := t.NumOut()\n\tfor i := 1; i <= resN; i++ {\n\t\ts.g.WriteStringf(\"r%d\", i)\n\t\tif i != resN {\n\t\t\ts.g.WriteStringf(\", \")\n\t\t}\n\t}\n\ts.g.WriteStringfn(\" := s.%s(ctx, *r)\", doc.Name)\n\tfor i := resN; i > 0; i-- {\n\t\ts.g.WriteStringfn(\"if r%d != nil {\", i)\n\t\ts.g.WriteStringfn(\"resBt, _ = r%d.MarshalAyproto()\", i)\n\t\ts.g.WriteStringf(\"}\")\n\t\tif i != 1 {\n\t\t\ts.g.WriteStringf(\" else \")\n\t\t} else {\n\t\t\ts.g.WriteStringfn(\" else {\")\n\t\t\ts.g.WriteStringfn(\"resBt = ayproto.GenericErrorResp\")\n\t\t\ts.g.WriteStringfn(\"}\")\n\t\t}\n\t}\n}\n\nfunc (s *server) gen() {\n\ts.g.WriteStringfn(\"func (s *%s) ServeAYProto(ctx context.Context, c ayproto.Conn, p ayproto.Packet) {\", s.s.getType())\n\ts.g.WriteStringfn(\"var resBt []byte\")\n\ts.g.WriteStringfn(\"switch p.Header.Msg {\")\n\tfor i := 0; i < len(s.descrs); i++ {\n\t\ts.genHandle(s.ms[i], s.descrs[i])\n\t}\n\ts.g.WriteStringfn(\"default:\")\n\ts.g.WriteStringfn(\"resBt = ayproto.GenericErrorResp\")\n\ts.g.WriteStringfn(\"}\")\n\ts.g.WriteStringfn(\"err := c.Send(ctx, ayproto.ResponseTo(p, resBt))\")\n\ts.g.WriteStringfn(\"if err != nil {\")\n\ts.g.WriteStringfn(\"fmt.Println(err)\")\n\ts.g.WriteStringfn(\"}\")\n\ts.g.WriteStringfn(\"}\")\n}\n"}, bootstrap.GFile{Name:"packgen/types.go", Content:"package packgen\n\nimport \"reflect\"\n\ntype FieldType int\n\nfunc nameFromReflect(k reflect.Kind) (string, error) {\n\tswitch k {\n\tcase reflect.Int:\n\t\treturn \"int\", nil\n\tcase reflect.Int8:\n\t\treturn \"int8\", nil\n\tcase reflect.Int16:\n\t\treturn \"int16\", nil\n\tcase reflect.Int32:\n\t\treturn \"int32\", nil\n\tcase reflect.Int64:\n\t\treturn \"int64\", nil\n\tcase reflect.Uint:\n\t\treturn \"uint\", nil\n\tcase reflect.Uint8:\n\t\treturn \"uint8\", nil\n\tcase reflect.Uint16:\n\t\treturn \"uint16\", nil\n\tcase reflect.Uint32:\n\t\treturn \"uint32\", nil\n\tcase reflect.Uint64:\n\t\treturn \"uint64\", nil\n\tcase reflect.String:\n\t\treturn \"string\", nil\n\tdefault:\n\t\treturn \"\", ErrBadType\n\t}\n}\n"}}